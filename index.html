<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hum to Lyrics â€“ Vocal & Lyric Rescue</title>
<style>
  body { font-family: system-ui, sans-serif; padding: 1rem; background: #0b0c10; color: #e5e7eb; }
  button, input, select { padding: 0.75rem 1rem; font-size: 1rem; border-radius: .5rem; border: none; }
  button { cursor: pointer; }
  .rec { background: #4f46e5; color: white; animation: pulse 1s infinite; }
  @keyframes pulse { 0%{box-shadow:0 0 0 0 rgba(79,70,229,.6);} 70%{box-shadow:0 0 0 20px rgba(79,70,229,0);} 100%{box-shadow:0 0 0 0 rgba(79,70,229,0);} }
  .search { margin-top: 1rem; display: flex; gap: 0.5rem; }
  input, select { flex: 1; border: 1px solid rgba(255,255,255,0.2); background: #111217; color: #e5e7eb; }
  pre { white-space: pre-wrap; background: #111217; padding: 1rem; border-radius: .5rem; margin-top: 1rem; }
  #debugPanel{margin-top:.75rem;background:#141622;border:1px solid rgba(255,255,255,.1);border-radius:.5rem}
  #debugPanel header{padding:.5rem .75rem;font-weight:600;font-size:.9rem;opacity:.8}
  #debug{max-height:24vh;overflow:auto;margin:0;padding:.75rem;background:transparent;color:#93c5fd;font-size:0.85rem}
</style>
</head>
<body>
<h1>Hum to Lyrics</h1>
<p id="status">Tap the mic, hum or sing for ~8 seconds.</p>
<label><input type="checkbox" id="lyricRescue" checked> Enable Lyric Rescue</label>
<select id="langSel">
  <option value="auto" selected>Auto language</option>
  <option value="en-GB">English (UK)</option>
  <option value="en-US">English (US)</option>
</select>
<button id="micBtn">ðŸŽ¤</button>
<div class="search">
  <input id="lyricQuery" placeholder="Or type a lyric snippetâ€¦">
  <button id="searchBtn">Search</button>
</div>
<div id="debugPanel">
  <header>Debug</header>
  <pre id="debug"></pre>
</div>
<pre id="output"></pre><script>
// Minimal pipeline: AudD (audio fingerprint) â†’ Whisper (/api/transcribe) â†’ AudD lyrics search
const micBtn = document.getElementById('micBtn');
const statusEl = document.getElementById('status');
const resultCard = document.getElementById('resultCard');
const cover = document.getElementById('cover');
const songTitle = document.getElementById('songTitle');
const songArtist = document.getElementById('songArtist');
const lyricsEl = document.getElementById('lyrics');

let mediaRecorder, chunks = [];

async function recordOnce(ms=8000){
  const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true } });
  return new Promise((resolve, reject)=>{
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
    chunks = [];
    mediaRecorder.ondataavailable = e => chunks.push(e.data);
    mediaRecorder.onerror = e => reject(e.error || e);
    mediaRecorder.onstop = ()=>{
      const blob = new Blob(chunks, { type: 'audio/webm' });
      stream.getTracks().forEach(t=>t.stop());
      resolve(blob);
    };
    mediaRecorder.start();
    setTimeout(()=>{ if(mediaRecorder && mediaRecorder.state==='recording') mediaRecorder.stop(); }, ms);
  });
}

async function identifyWithAudD(blob){
  const res = await fetch('/api/audd', { method:'POST', headers:{ 'Content-Type':'application/octet-stream' }, body: blob });
  if (!res.ok) throw new Error('AudD proxy failed: '+res.status);
  const json = await res.json();
  if (!json || !json.result) throw new Error(json.error?.error_message || 'No match');
  return json.result;
}

async function transcribeServer(blob){
  const r = await fetch('/api/transcribe', { method:'POST', headers:{ 'Content-Type':'application/octet-stream' }, body: blob });
  if (!r.ok) throw new Error('Transcribe failed '+r.status);
  return r.json(); // { text: '...' }
}

async function findLyricsByText(q){
  const res = await fetch(`/api/audd-lyrics?q=${encodeURIComponent(q)}`);
  if (!res.ok) throw new Error('Lyrics lookup failed');
  const json = await res.json();
  if (!json.result || !json.result.length) throw new Error('No lyrics found');
  // pick the longest lyrics body as a simple confidence proxy
  json.result.sort((a,b)=> (b.lyrics?.length||0) - (a.lyrics?.length||0));
  return json.result[0];
}

function renderResult(r){
  resultCard.classList.remove('hidden');
  songTitle.textContent = r.title || 'Unknown title';
  songArtist.textContent = r.artist || r.artist_name || 'Unknown artist';
  const img = (r.spotify?.album?.images?.[0]?.url) || r.deezer?.album?.cover_big || (r.apple_music?.artwork?.url||'').replace('{w}x{h}','200x200') || '';
  if (img) cover.src = img; else cover.removeAttribute('src');
  lyricsEl.textContent = r.lyrics?.lyrics || r.lyrics || 'No licensed lyrics available.';
}

function cleanTranscript(t){
  return String(t||'')
    .replace(/\b(uh|um|erm|like|you know|hmm|ah)\b/gi,'')
    .replace(/\s{2,}/g,' ')
    .trim();
}

async function go(){
  try{
    micBtn.classList.add('rec');
    statusEl.textContent = 'Recordingâ€¦';
    const blob = await recordOnce(9000);
    micBtn.classList.remove('rec');
    statusEl.textContent = 'Identifyingâ€¦';

    // 1) AudD audio fingerprint (primary)
    try{
      const a = await identifyWithAudD(blob);
      renderResult(a);
      statusEl.textContent = 'Done.';
      return;
    }catch(e){ /* fall back to transcription */ }

    // 2) Whisper â†’ lyrics search (fallback)
    try{
      statusEl.textContent = 'Transcribingâ€¦';
      const t = await transcribeServer(blob);
      const text = cleanTranscript(t?.text || '');
      if (text.split(/\s+/).length >= 3){
        const l = await findLyricsByText(text);
        renderResult({ title: l.title || '(lyrics match)', artist: l.artist || '', lyrics: l.lyrics });
        statusEl.textContent = 'Found by transcription.';
        return;
      }
      throw new Error('Not enough words captured');
    }catch(e){
      resultCard.classList.remove('hidden');
      songTitle.textContent = 'No match';
      songArtist.textContent = '';
      cover.removeAttribute('src');
      lyricsEl.textContent = 'Couldnâ€™t identify from audio or lyrics.';
      statusEl.textContent = 'Tap the mic to try again.';
    }
  }catch(err){
    statusEl.textContent = 'Error: ' + (err.message || 'Unknown error');
  }
}

micBtn.addEventListener('click', ()=>{
  if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
  else go();
});
</script>

</body>
</html>
