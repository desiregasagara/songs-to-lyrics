<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hum to Lyrics â€“ Vocal & Lyric Rescue</title>
<style>
  body { font-family: system-ui, sans-serif; padding: 1rem; background: #0b0c10; color: #e5e7eb; }
  button, input, select { padding: 0.75rem 1rem; font-size: 1rem; border-radius: .5rem; border: none; }
  button { cursor: pointer; }
  .rec { background: #4f46e5; color: white; animation: pulse 1s infinite; }
  @keyframes pulse { 0%{box-shadow:0 0 0 0 rgba(79,70,229,.6);} 70%{box-shadow:0 0 0 20px rgba(79,70,229,0);} 100%{box-shadow:0 0 0 0 rgba(79,70,229,0);} }
  .search { margin-top: 1rem; display: flex; gap: 0.5rem; }
  input, select { flex: 1; border: 1px solid rgba(255,255,255,0.2); background: #111217; color: #e5e7eb; }
  pre { white-space: pre-wrap; background: #111217; padding: 1rem; border-radius: .5rem; margin-top: 1rem; }
  #debugPanel{margin-top:.75rem;background:#141622;border:1px solid rgba(255,255,255,.1);border-radius:.5rem}
  #debugPanel header{padding:.5rem .75rem;font-weight:600;font-size:.9rem;opacity:.8}
  #debug{max-height:24vh;overflow:auto;margin:0;padding:.75rem;background:transparent;color:#93c5fd;font-size:0.85rem}
</style>
</head>
<body>
<h1>Hum to Lyrics</h1>
<p id="status">Tap the mic, hum or sing for ~8 seconds.</p>
<label><input type="checkbox" id="lyricRescue" checked> Enable Lyric Rescue</label>
<select id="langSel">
  <option value="auto" selected>Auto language</option>
  <option value="en-GB">English (UK)</option>
  <option value="en-US">English (US)</option>
</select>
<button id="micBtn">ðŸŽ¤</button>
<div class="search">
  <input id="lyricQuery" placeholder="Or type a lyric snippetâ€¦">
  <button id="searchBtn">Search</button>
</div>
<div id="debugPanel">
  <header>Debug</header>
  <pre id="debug"></pre>
</div>
<pre id="output"></pre>
<script>
const micBtn = document.getElementById('micBtn');
const statusEl = document.getElementById('status');
const output = document.getElementById('output');
const debugEl = document.getElementById('debug');
const lyricRescue = document.getElementById('lyricRescue');
const lyricQuery = document.getElementById('lyricQuery');
const searchBtn = document.getElementById('searchBtn');
const langSel = document.getElementById('langSel');
let mediaRecorder, chunks = [];

function dbg(label, val){
  if(!debugEl) return;
  const s = typeof val === 'string' ? val : (val ? JSON.stringify(val) : '');
  debugEl.textContent += `[${new Date().toLocaleTimeString()}] ${label}: ${s}\n`;
  debugEl.scrollTop = debugEl.scrollHeight;
}

async function recordOnce(ms=8000) {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  return new Promise((resolve, reject) => {
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
    chunks = [];
    mediaRecorder.ondataavailable = e => chunks.push(e.data);
    mediaRecorder.onerror = e => reject(e.error || e);
    mediaRecorder.onstop = () => resolve(new Blob(chunks, { type: 'audio/webm' }));
    mediaRecorder.start();
    setTimeout(() => { if (mediaRecorder.state === 'recording') mediaRecorder.stop(); }, ms);
  });
}

async function findLyricsByText(q) {
  dbg('Lyrics query', q);
  const res = await fetch(`/api/audd-lyrics?q=${encodeURIComponent(q)}`);
  if (!res.ok) throw new Error('Lyrics lookup failed');
  const json = await res.json();
  if (!json.result || !json.result.length) throw new Error('No lyrics found');
  json.result.sort((a,b)=>(b.lyrics?.length||0)-(a.lyrics?.length||0));
  return json.result[0];
}

async function lyricRescueListen(ms=8000) {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) throw new Error('Speech recognition not supported');
  return new Promise((resolve, reject) => {
    const r = new SR();
    let transcript = '';
    r.continuous = false;
    r.interimResults = true;
    r.lang = (langSel.value !== 'auto') ? langSel.value : (navigator.language || 'en-US');
    const timer = setTimeout(()=>{ try{ r.stop(); }catch{} }, ms);
    r.onresult = e => {
      for (let i = e.resultIndex; i < e.results.length; i++) {
        if (e.results[i].isFinal) transcript += e.results[i][0].transcript + ' ';
      }
      dbg('Browser SR heard', transcript.trim());
    };
    r.onerror = e => { clearTimeout(timer); reject(new Error(e.error||'Speech error')); };
    r.onend = () => { clearTimeout(timer); resolve(transcript.trim()); };
    try { debugEl.textContent = ''; r.start(); statusEl.textContent = 'Listening for lyricsâ€¦'; }
    catch(err){ clearTimeout(timer); reject(err); }
  });
}

function cleanTranscript(t){
  const fillers = ['uh','um','erm','like','you know','hmm','ah'];
  let s = String(t||'');
  for (const f of fillers){ s = s.replaceAll(' '+f+' ',' '); }
  while (s.indexOf('  ') !== -1) s = s.replaceAll('  ',' ');
  return s.trim();
}

async function transcribeServer(blob){
  const r = await fetch('/api/transcribe', {
    method: 'POST',
    headers: { 'Content-Type': 'application/octet-stream' },
    body: blob
  });
  if (!r.ok) throw new Error('Transcribe failed '+r.status);
  return r.json();
}

async function identify2(blob) {
  dbg('Identify','start');
  try {
    dbg('AudD request', `audio ${blob.size} bytes`);
    const res = await fetch('/api/audd', { method: 'POST', headers: { 'Content-Type': 'application/octet-stream' }, body: blob });
    if (res.ok) {
      const data = await res.json();
      if (data && data.result){ dbg('AudD match', `${data.result.title} â€” ${data.result.artist || data.result.artist_name || ''}`); return data.result; }
      dbg('AudD response', data?.error?.error_message || 'no result');
    } else {
      dbg('AudD http', res.status + ' ' + res.statusText);
    }
  } catch(e) { dbg('AudD error', e.message || String(e)); }

  if (lyricRescue.checked) {
    try {
      const heardRaw = await lyricRescueListen(11000);
      const heard = heardRaw;
      dbg('Browser SR heard', heard || '(empty)');
      if (heard && heard.split(/\s+/).length >= 3) {
        const byText = await findLyricsByText(heard);
        dbg('Lyrics match', `${byText.title || '(lyrics match)'} â€” ${byText.artist || ''}`);
        return byText;
      }
    } catch(e) { dbg('Lyric rescue error', e.message || String(e)); }
  }

  try {
    dbg('Whisper request', `audio ${blob.size} bytes`);
    const t = await transcribeServer(blob);
    if (t && t.text) {
      const text = cleanTranscript(t.text);
      dbg('Whisper text', text || '(empty)');
      if (text.split(/\s+/).length >= 3) {
        const byText = await findLyricsByText(text);
        dbg('Lyrics match', `${byText.title || '(lyrics match)'} â€” ${byText.artist || ''}`);
        return byText;
      }
    }
  } catch(e) { dbg('Whisper error', e.message || String(e)); }

  dbg('Identify','no match');
  return { title: 'No match', artist: '', lyrics: 'Nothing found' };
}

async function go() {
  try {
    debugEl.textContent = '';
    micBtn.classList.add('rec');
    statusEl.textContent = 'Recordingâ€¦';
    const blob = await recordOnce();
    micBtn.classList.remove('rec');
    statusEl.textContent = 'Processingâ€¦';
    const result = await identify2(blob);
    output.textContent = JSON.stringify(result, null, 2);
    statusEl.textContent = 'Done';
  } catch (err) {
    statusEl.textContent = 'Error: ' + err.message;
  }
}

searchBtn.addEventListener('click', async () => {
  const q = lyricQuery.value.trim();
  if (!q) return;
  statusEl.textContent = 'Searching lyricsâ€¦';
  try {
    const r = await findLyricsByText(q);
    output.textContent = JSON.stringify(r, null, 2);
    statusEl.textContent = 'Found by lyrics.';
  } catch(e) {
    statusEl.textContent = 'No lyrics found.';
  }
});

micBtn.onclick = () => {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    mediaRecorder.stop();
  } else {
    go();
  }
};
</script>
</body>
</html>
